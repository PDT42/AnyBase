# Notes

## 1 - 2020/07/12 Navigation

Die Navigation stellt im Projekt offensichtlich eine Schwierigkeit dar. Die Navigation wird n√∂tig, wenn wir anfangen √ºber eine Webapp mit seperatem Backend nachzudenken. Ich werde hier Ideen sammeln, wie die Navigation funktionieren k√∂nnte und werde versuchen so viele Cases wie m√∂glich zu √ºberdenken bevor ich mit der Implementierung beginne. Ich habe in textual requirements beschrieben, dass ich mir pro AssetType zwei Seiten vorstelle. Damit meine ich eine Seite bei der eine Art "Listen Ansicht" verf√ºgbar ist, es stehen alle Elemente des AssetTypes zur Verf√ºgung (Wie der Nutzer diese Daten dann darstellt ist den Plugins √ºberlassen). Die zweite Seite ist eine Detailansichtsseite f√ºr ein Asset. Diese Seite geh√∂rt dann aber eigentlich nicht mehr zum AssetType, sondern zum Asset.
Bei der Navigation sollte ber√ºcksichtigt werden, dass Routen zur Verf√ºgung stehen, mit denen die Manager Funktionen direkt zur Verf√ºgung stehen. So k√∂nnen speziell angepasste Frontends auf dem Framework entwickelt werden und nachtr√§glich auf die bestehende Software aufgesetzt werden. 

## 2 - 2020/08/20 (Keine) Routen Semantik und Asynchrones Nachladen

Einige der Routen sind inzwischen implementiert - bisher hatte ich noch nicht das Bef√ºrnis eine offizielle Path Semantik einzuf√ºhren. Daf√ºr gibt es bisher einfach noch nicht genug verschiedene Routen. Derzeit sind Routen im Normalfall in etwa so aufgebaut: ``/thema/item_id/action`` - dabei ``thema`` bisher in der Regel ``asset_type`` oder ``asset``. Der Abschnitt ``item_id`` identifiziert das Item das betrachtet/bearbeitet werden soll - ``action`` ist kein notwendiger Wert, aber kann angegeben werde (z.B. ``create``, ``delete``, ...). Alles sehr unspektakul√§r. 

Erw√§hnenswerter ist eine Routen Logik die ich in ``asset_server`` implementiert habe. Mit der ``action``: ``items`` wird die Methode ``request_asset_data`` aufgerufen. 

Um diese Methode zu erm√∂glichen habe ich mich entschieden das im Projekt verwendete Framework zu √§ndern. Anstatt von [Flask] wird nun [Quart] verwendet. [Quart] ist effektiv eine Implementierung von [Flask], die asynchrone Routen zul√§sst. Zu [Quart] und dem zugrunde liegenden Framework wird noch ein eigener Dokumentations Artikel angelegt werden m√ºssen. [Quart]'s Implementierung der ``make_response`` Methode, die auch von [Flask] angeboten wird, kann awaited werden. Die Inhalte werden in Form eines EventStreams an das Frontend ausgeliefert. Wie die einzelnen Events dieses Streams aussehen, wird durch die generator Methode definiert, die als Parameter in ``make_response`` eingeht. Die einzelnen Werte, die diese Generator Methode zur√ºckliert, m√ºssen utf8 codiert werden. Es ist also sinnvoll, die Items, die ausgeliefert werden, JSON kompatibel zu kodieren. In der Generator Methode k√∂nnen Asynchrone Tasks gestartet werden, die dann nach und nach geyielded werden. [Quart] verwendet f√ºr Asychrone Tasks asyncio, also habe ich das auch gemacht. Sehr simpel. Der Code ist sehr straight forward und gut lesbar.

Die erw√§hnte Route liefert Items (in diesem Fall offensichtlich ``Assets``, also die Items, die en masse in der ``AssetTypePage`` zur Verf√ºgung stehen m√ºssen) asynchron aus. Dazu wird im Frontend eine EventSource definiert, an die ein ``EventListener`` angeh√§ngt wird. Der Name des Events auf das der Listener h√∂ren soll, wird durch den ``result_message`` Parameter ``event`` in der Methode ``request_asset_data`` angegeben. Die ``result_message``, die an das Frontend ausgeliefert wird, wird so formattiert, dass sie im Frontend durch ``JSON.parse()`` ausgelesen werden kann. In diesem Fall ist das Resultat ein JSON, in dem die beiden keys ``items`` und ``item_count`` zur Verf√ºgung stehen. Die Methode im Backend ist, wie schon erw√§hnt, sehr straight forward und ich bin immernoch √ºberrascht wie clean sich so eine Funkitonalit√§t implementieren lie√ü. Im Frontend ist das eine ganz andere Geschichte. Ich habe nicht genug Erfahrung mit Javascript um eine _sch√∂ne_ Implementierung eines Brokers abzuliefern. Ein Broker, w√ºrde den ``EventListener`` und ein PubSub System kombinieren. Ich bin mir nicht hundert Prozent sicher, aber ich glaube ein PubSub System ist notwendig um die Inhalte der Seite dynamisch zu updaten, wenn _neue Items ankommen_. Ich habe einfach viel zu wenig Frontend Erfahrung um einen Pattern zu kennen, mit dem solche Probleme in der Regel gel√∂st werden - Ich werde wohl mal googlen m√ºssen üôà. Zus√§tzlich erschwert wird das Problem, durch die Art und Weise, wie die Layouts aufgebaut werden. Weil die Plugins auf Basis der Nutzer Einstellungen dynamisch eingef√ºgt werden, befindet sich der Code f√ºr die Plugins in einem anderen JavaScript File, als das _Dom Element an dem der_ Broker sinnvollerweise initialisiert werden sollte. Nicht jedes Plugin, braucht seinen eigenen Borker. Desshalb w√ºrde ich den Broker gern als Singleton implementieren. Der Layout Generator w√ºrde den Broker initialisieren und die Plugins h√§tten einfachen Zugriff, durch eine ``get_instance`` Funktion. Vielleicht kann ich ja wirklich irgendwen fragen, ob er mir da hilft. 

Ich habe kurzerhand Florian gefragen und er hat mich auf [RxJs] hingewiesen - Ich glaube er dachte: "LOL, was f√ºr'n Noob" üôà - Naja.


[//]: # (LINKS)
[RxJs]: https://github.com/ReactiveX/rxjs
[Quart]: https://github.com/pgjones/quart
[Flask]: https://github.com/pallets/flask

[//]: # (IMAGES)
